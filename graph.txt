그래프 - 자료 구조
: 일상에서 가장 보편적이며 그러므로 가장 복잡한 자료구조이다
그래프 = (v, e) -> 그래프는 버텍스(노드)와 에지(링크)의 조합이라고 볼 수 있다.
그래프는 인접성에 따라 크게 두 가지로 표현할 수 있다.
첫째는 인접 행렬이다.
1. 인접 행렬은 어떤 노드에서 다른 노드로 갈 수 있건 없건 모두 값(0, 1, etc)을
부여하는 방식이기 때문에 메모리 크기 관점에서 보면 O(n**2)이다.
2. 인접 행렬은 어떤 에지가 에지 집합에 속해있는지를 확인하는 데 필요한
시간복잡도가 O(1)로 상수이다. G[u][v] == 1(or 가중치)인지만 확인하면 되기 때문이다
3. 인접 행렬은 u에 인접한 모든 노드 v를 알아내고자 할때, 
for v in range(1, n + 1)
    do with G[u][v]
이런 식으로 그 노드에 대한 모든 컬럼을 돌면서 그 값을 확인해야 하기 때문에,
시간 복잡도가 O(n)이다.
4. 인접 행렬에서 새로운 에지를 삽입하는 경우 그냥 G[u][v] = 1 이런 식으로
구현하면 되기 때문에 삽입에 걸리는 시간 복잡도는 O(1) 상수 시간복잡도이다.
5. 인접 행렬에서 어떤 에지 (u, v)를 삭제하는 경우, 시간 복잡도는 O(1)로
상수 시간 복잡도를 갖는다. 그냥 G[u][v] = 0 이 되도록 만들어주기만 하면 되기 때문이다.

둘째는 인접 (연결) 리스트이다. 
1. 인접 연결 리스트는 1차원 배열 각각의 인덱스를 연결 리스트로 구성하여 구현한다.
연결 리스트의 각 노드의 데이터는 에지 집합에 존재하는 v로만 구성되기 때문에,
인접 연결 리스트를 표현하는 데 드는 공간적인 복잡도는 O(n+m)이다.
이는 버텍스의 수에 비해 에지가 적은 경우 특히 인접 행렬(O(n**2))보다 효과적이다.
2. 인접 연결 리스트는 어떤 에지가 에지 집합에 속해있는지를 확인하는 데 필요한
시간 복잡도가 O(n)이다. 에지 (u, v)가 에지 집합에 속해있는지를 확인하려면 
u 연결 리스트를 끝까지 순회하면서 v가 있는지 없는지를 확인해야 하는데,
최악의 경우, u가 모든 노드와 에지 관계를 이루고 있고, 찾는 노드 v가 연결 리스트의
맨 마지막에 있으면 n번 순회해야 하기 때문이다.
3. 인접 리스트는 u에 인접한 모든 노드 v를 알아내고자 할때 일반적으로 인접 행렬에
비해서 더 적은 시간이 소모된다. u가 모든 노드와 인접해 있는 경우에는 n번 순회해야
하긴 하겠지만, 그렇지 않은 경우, 실제로 인접해 있는 수 딱 그만큼만 돌면 되기 때문에
시간 복잡도가 낮을 확률이 높다.
4. 인접 리스트에서 새로운 에지를 삽입하는 경우 g[u].append(v) 또는
g[u].pushFront(v) 등을 통해 연결 리스트에 노드를 삽입해주어야 한다.
이런 경우에 시간복잡도는 O(1)으로 상수 시간복잡도이고 이는 인접 행렬의 경우와 차이가 없다.
5. 인접 리스트는 어떤 에지 (u, v)를 삭제하는 경우, 시간 복잡도가 O(n)이다.
삭제하려면 이런 식으로 구현되어야 한다.
delData = G[u].search[v]
G[u].remove(delData) 
즉, 일단 삭제할 그 에지를 연결 리스트 상에서 찾는 과정이 필요하고 이는,
최악의 경우 n까지 순회하게 할 수 있기 때문에 상수 시간복잡도를 갖는 인접 행렬에 비해 불리하다.


